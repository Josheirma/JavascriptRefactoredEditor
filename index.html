  <html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JS Editor</title>
  </head>
  <body>
  <script src="cursorMovements.js"></script>
  <script src="newestRecursivs.js"></script>
  <link rel= 'stylesheet' href='styles.css'>
  
  
  <script>
    

    let CursorMovements = null;
    let Recursive = null;
    let inserting;
    let dashing;
    // Initialize the classes for cursor movement and recursion (assumed to be defined elsewhere)
  document.addEventListener("DOMContentLoaded", () => {
  CursorMovements = new CursorMovementsClass();
  Recursive = new RecursiveClass();
  inserting = document.getElementById('insert')
  dashing = document.getElementById('areDashes')
  // Add event listener to Button 1
  // Check if buttons exist before adding event listeners
  if (inserting) {
    inserting.addEventListener('pointerdown', handleInsertButtonClick);
  } else {
    console.error("Insert button not found");
  }

  if (dashing) {
    dashing.addEventListener('pointerdown', handleDashesButtonClick);
  } else {
    console.error("Dashes button not found");
  }

  // your setup logic here
  });

    // Starting dimensions for the cursor movement
    let STARTING_HORIZ = 400;  // Starting position on the X-axis
    let STARTING_VERTI = 380;   // Starting position on the Y-axis
    //browser values for min and max width, used for sizing
    let SMALLES_INNER_WIDTH = 1.4;
    let SMALLER_INNER_HEIGHT = 3.97;
    let LARGER_INNER_WIDTH = 2.6;
    let LARGER_INNER_HEIGHT = 4.937;
    

    // Dash character to replace spaces for display
    let DASH = '-';
    let areDashes = true; // Flag to toggle dash display instead of spaces
</script>

<!-- Canvas element for rendering content -->
<div class = "entireContainer">
<div class = "title">
Javascript Text Editor
</div>
<div class = "canvas" >
<canvas id="canvas_id" width="400" height="400" style="border: 1px solid #550233;"></canvas>
</div>
<!-- Display horizontal and vertical positioning -->
<div class = "containsXAndY">
<div id="xAndY" >Horizontal: &nbsp0&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspVertical: 0  </div>
</div>
<!-- Container for buttons displayed in a column layout -->
<div class = "buttonContainer">
    <!-- Button for inserting content directly on top of the canvas -->
    <button class = "insertButton" id="insert">
        Insert
    </button>
    
    <!-- Button to toggle between showing spaces and dashes -->
    <button class = "dashesButton" id="areDashes">
        Show Without Dashes
    </button>
</div>
</div>
<script>
  
  //keep track of cursor location, horizontal step is 5, and vertical step is 10
  let horizontalCursorPosition = 0
  let verticalCursorPosition = 0
  //Max rows before any create rows
  let MAXROWS = 15
  
  
  let gridArray = [
    
    ["1", "2", "A", "A", "A", "A" , "A", "A", "A", "A", "A", "A", "A" , "A", "A", "A", "1", "A", "A", "A" , "A","A", "A", "A", "A", "A", "1", "2" ],
    ["A", DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, "2", DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    ["1", "2", "3", DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
     
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, "z", "y", "c", "b", "a" ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, "1", "2", "3" ],
     
    ["Q", "W", DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, "1", "2" ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, "A", "B", "C" ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, "D" ],
         
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, "Y" ],
    ["B", DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, "Z" ],
    ["A", DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, "B", "C" ],
          ];
    /*
    let gridArray = [
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
     
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
     
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
         
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
         //["!", "!", "!", "!", "!", "!" , "!", "!", "!", "!", "!", "!", "!" , "!", "!", "!", "!", "!", "!", "!" , "!", "!","!", "!", "!", "!", "!" , "!" ],
    ];
    */
  


  // Grid dimensions
  const WIDTH = 28;
  let HEIGHT = 15;
  const ORIGINALHEIGHT = 15;

  // Cursor canvas offsets
  const VOFFSET = 32;
  const HOFFSET = 35;

  // Copy grid (ensure it's used somewhere in your logic)
  let copy2DimArray = [];

  // Canvas and context
  const canvas = document.getElementById('canvas_id');
  if (!canvas) {
    console.error("Canvas element with ID 'canvas_id' not found.");
    
  }

  const ctx = canvas.getContext('2d');
  if (!ctx) {
    console.error("Failed to get 2D context from canvas.");
    
  }

  // Initial insert mode state
  let insertOn = true;
  // Cursor tracking
  let lastAdjustedX = -1;  // fixed typo from 'lastAdujstedX'
  let lastAdjustedY = -1;  // fixed typo from 'lastAdujstedY'








// Function to initialize the canvas size and appearance

function makeCanvas(verticalSize = 190, horizontalSize = 200) {
    // Set canvas display size
    canvas.style.width = `${horizontalSize}px`;
    canvas.style.height = `${verticalSize}px`;

    // For crisper imaging on high DPI screens
    const scale = window.devicePixelRatio;

    // Set the canvas' internal resolution to match the display size, scaled for better display
    canvas.width = horizontalSize * scale;
    canvas.height = verticalSize * scale;

    // Apply scaling to match the display resolution
    ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset any previous transform
    ctx.scale(scale, scale);

    // Set canvas background to white
    ctx.fillStyle = '#ffffff';

    // Clear canvas (white background)
    ctx.fillRect(0, 0, 200, 200);

    // Set font and text alignment
    ctx.font = '10px Monospace';
    ctx.textAlign = 'center';
}
 

//////////



  
  
  

  
  function drawGrid(iValue = HEIGHT, jValue = WIDTH) {

   
    // Ensure that gridArray is defined and has at least 'iValue' rows and 'jValue' columns
    if (!gridArray || gridArray.length < iValue || gridArray[0].length < jValue) {
        console.log("bad array");
        return; // Exit the function early if the grid is invalid
    }

    // Calculate the number of extra rows beyond the original height
    let extraHeightRows = HEIGHT - ORIGINALHEIGHT;
    // For each additional row, increase canvas height by 10 pixels
    let totalVert = extraHeightRows * 20 + STARTING_VERTI + 20;

    // Make sure to resize the canvas with new dimensions
    //to change dimensions add to these values and change ivalue, jvalue, an xpos and ypos offset
    makeCanvas(totalVert, STARTING_HORIZ);
   
    // Set the fill color for the grid text (black)
    ctx.fillStyle = 'black';
    ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset any previous transform
    ctx.scale(2, 2);
    // Loop through the grid and render each cell's text
    for (let i = 0; i < iValue; i++) {
        for (let j = 0; j < jValue+40; j++) {
            // Check if the current grid cell exists and is valid
            let cellText = (gridArray[i] && gridArray[i][j]) ? gridArray[i][j] : ""; // Default to empty string if invalid
            // Calculate the x and y positions based on the grid layout
            // 6 locations before text starts
            let xPos = j * 5 + 30;
            let yPos = i * 10 + 33;
            // Render the text in the canvas at calculated positions
            ctx.fillText(cellText, xPos, yPos);
        }
    }
}

  //draws cursor on grid
 

  ////////////////////////////////start here

  
  function drawCursor(x,y){
    
    ctx.font = '10px Monospace'
    ctx.fillStyle = 'red'
    ctx.fillText('_', x - 5, y)
    }


    //holds key pressed
    let gKey = ''
    //array that holds key code, (number)
    var keyState = {}
    let down = false
    
  // Function to handle Insert button click event
  
  function handleInsertButtonClick() {
  // Toggle the insertOn flag
  insertOn = !insertOn;

  // Get the insert button element
  const insertButton = document.getElementById("insert");

  // Check if the button exists to avoid runtime errors
  if (!insertButton) {
    console.error("Insert button element not found");
    return;
  }

  // Update button text based on the insertOn state
  insertButton.innerHTML = insertOn ? "Insert" : "On Top";
}
    

    // This function handles the button click to toggle between displaying dashes and spaces on the grid
     
    function handleDashesButtonClick() {
    // Toggle the dash state: if showing dashes, switch to spaces, and vice versa.
    if (areDashes) {
        DASH = " ";  // Set DASH to space when toggling off
    } else {
        DASH = "-";  // Set DASH to dash when toggling on
    }

    // If currently displaying dashes, change grid content to spaces
    if (areDashes) {
        // Save a deep copy of the current grid state (with dashes) for future restoration
        copy2DimArray = gridArray.map(arr => [...arr]);

        // Loop through the grid and replace all dashes with spaces
        for (let i = 0; i < HEIGHT; i++) {
            for (let j = 0; j < WIDTH; j++) {
                if (gridArray[i][j] === "-") {
                    gridArray[i][j] = " ";  // Replace dash with space
                }
            }
        }

        // Toggle the areDashes flag to indicate we are now showing spaces
        areDashes = !areDashes;

    } else {
        // If currently displaying spaces, restore the grid state with dashes
        gridArray = copy2DimArray.map(arr => [...arr]);

        // Toggle the areDashes flag to indicate we are now showing dashes
        areDashes = !areDashes;
    }

    // Update the button text to reflect the current display state
    if (areDashes) {
        document.getElementById("areDashes").innerHTML = "Show Without Dashes";  // When showing dashes
    } else {
        document.getElementById("areDashes").innerHTML = "Continue Coding";  // When showing spaces
    }

    // Redraw the grid based on the current display mode (dashes or spaces)
    drawGrid(HEIGHT, WIDTH);

        Recursive.displayGridAndCursor();
    
}


    

   document.body.addEventListener('keydown', function (e) {
    // Mark the key as pressed based on its keyCode
    keyState[e.keyCode] = true;

    // Store the key that was pressed
    gKey = e.key;

    // Prevent multiple keydown events from triggering simultaneously
    if (down) return;
    down = true;

    // Call functions related to cursor movement and other actions
    cursorAndFunctionCalls();
    displayCursorLocations();

    // The event is simply captured and handled here
    }, false);

    document.addEventListener('keyup', function (e) {
    // Mark the key as released based on its keyCode
    keyState[e.keyCode] = false;

    // Store the key that was released
    gKey = e.key;

    // Reset the down flag as the key is no longer pressed
    down = false;

    // Simply captures the event
    }, false);
     
    //these keys dont do anything
    const preventKeys = [
    'Tab', 'PageUp', 'PageDown', 'Home', 'End','Control', 'Alt', 'Meta', 'Shift', 'Escape'
    ];
    
    // This function updates the display of the cursor's current horizontal and vertical positions
    
    function displayCursorLocations() {
    // Get the DOM element where the cursor positions will be displayed
    let cursorDisplayElement = document.getElementById("xAndY");

    // Calculate the cursor's horizontal and vertical positions (scaled by 5 and 10, respectively)
    // These divisions are used to map the grid's cursor positions to human-readable coordinates
    let horizontalPosition = horizontalCursorPosition / 5;  // Horizontal position scaled by 5
    let verticalPosition = verticalCursorPosition / 10;    // Vertical position scaled by 10

    // Update the inner HTML of the element to display the current cursor positions
    cursorDisplayElement.innerHTML = 
        'Horizontal: ' + horizontalPosition + ' &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ' + 
        'Vertical: ' + verticalPosition;
}


    // This function handles the cursor movements and function calls based on key presses
    
    function cursorAndFunctionCalls(event) {
    // Display the current cursor positions (this line is currently commented out)
    // displayCursorLocations();

    // Check if the key pressed is in the preventKeys array, and if so, return without doing anything
    for (let i = 0; i < preventKeys.length; i++) {
        if (preventKeys[i] == gKey) {
            return;  // Exit the function if the key is in the preventKeys list
        }
    }

    // Handle cursor movement based on arrow keys
    if (keyState[39]) {  // Right arrow
        CursorMovements.cursorRight();
    }
    else if (keyState[37]) {  // Left arrow
        CursorMovements.cursorLeft();
    }
    else if (keyState[38]) {  // Up arrow
        CursorMovements.cursorUp();
    }
    else if (keyState[40]) {  // Down arrow
        CursorMovements.cursorDown();
    }

    // Handle functions for non-cursor movement keys
    else if (gKey === 'Delete' || gKey === 'Backspace') {
        // If Delete or Backspace is pressed, delete the character at the cursor position
        gridArray = Recursive.deleteAndPullCharacters(verticalCursorPosition / 10, horizontalCursorPosition / 5, gridArray);
    }
    else if (gKey == "Enter") {
        // If Enter is pressed, perform the action associated with Enter (e.g., adding a newline)
        gridArray = Recursive.pressedEnter(gridArray, verticalCursorPosition / 10, horizontalCursorPosition / 5, "", true, HEIGHT - 1);
    }
    else if (gKey !== "") {
        // If a character key is pressed, determine whether to insert or overwrite the character
        if (insertOn === true && gKey) {
            // Regular insert mode (moves text to insert the character)
            //gridArray = Recursive.initialInsertDoThisFirst(verticalCursorPosition / 10, horizontalCursorPosition / 5, gridArray, gKey, true);
        } else {
            // Destructive insert mode (overwrites the character at the cursor)
            //gridArray = Recursive.placeCharacterWithoutInsertDoThisFirst(verticalCursorPosition / 10, horizontalCursorPosition / 5, gridArray, gKey);
        }
    }

    // Ensure that words within the grid don't overflow and adjust if needed
    gridArray = Recursive.pushWordsDoThisSecond(gridArray, null, 1, true);

    // Redraw the grid and update the cursor display after any changes
    Recursive.displayGridAndCursor();
}
    //cursorAndFunctionCalls(event)


     </script>
    </body>
