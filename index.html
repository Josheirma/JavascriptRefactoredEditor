  <html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JS Editor</title>
  </head>
  <body>
  <script src="cursorMovements.js"></script>
  <script src="newestRecursivs.js"></script>
  <link rel= 'stylesheet' href='styles.css'>
  
  
  <script>
    // Initialize the classes for cursor movement and recursion (assumed to be defined elsewhere)
    const CursorMovements = new CursorMovementsClass();
    const Recursive = new RecursiveClass();

    // Starting dimensions for the cursor movement
    let STARTING_HORIZ = 200;  // Starting position on the X-axis
    let STARTING_VERTI = 190;   // Starting position on the Y-axis

    // Dash character to replace spaces for display
    let DASH = '-';
    let areDashes = true; // Flag to toggle dash display instead of spaces
</script>

<!-- Canvas element for rendering content -->
<canvas id="canvas_id" width="" height="" style="border: 1px solid #550233;"></canvas>

<!-- Display horizontal and vertical positioning -->
<div id="xAndY" style="font-size: .55rem; margin-left: 3rem;"></div>

<!-- Container for buttons displayed in a column layout -->
<div style="display: flex; margin-left: 1.15rem; margin-bottom: 0; padding-bottom: 0;">
    <!-- Button for inserting content directly on top of the canvas -->
    <button id="insert" style="padding-top: 0; margin-top: .25rem; width: 2rem; font-size: .4rem; margin-left: 20px;">
        Insert
    </button>
    
    <!-- Button to toggle between showing spaces and dashes -->
    <button id="areDashes" style="margin-top: .25rem; margin-left: .7rem; font-size: .4rem;">
        Show Without Dashes
    </button>
</div>
<script>
  
  //keep track of cursor location, horizontal step is 5, and vertical step is 10
  let horizontalCursorPosition = 0
  let verticalCursorPosition = 0
  //Max rows before any create rows
  let MAXROWS = 15
  
  
  let gridArray = [
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
     
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, "a" ],
     
    [" ", " ", "3", DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, "A", "B", "C" ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
         
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
         //["!", "!", "!", "!", "!", "!" , "!", "!", "!", "!", "!", "!", "!" , "!", "!", "!", "!", "!", "!", "!" , "!", "!","!", "!", "!", "!", "!" , "!" ],
    ];
    /*
    let gridArray = [
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
     
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
     
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
         
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
    [DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH, DASH, DASH, DASH, DASH, DASH, DASH , DASH,DASH, DASH, DASH, DASH, DASH, DASH, DASH ],
         //["!", "!", "!", "!", "!", "!" , "!", "!", "!", "!", "!", "!", "!" , "!", "!", "!", "!", "!", "!", "!" , "!", "!","!", "!", "!", "!", "!" , "!" ],
    ];
    */
  // Canvas configuration
// Dimensions for dashes/spaces grid
const WIDTH = 28;
const HEIGHT = 15;

// Column-related constants
const ORIGINALHEIGHT = 15;

// Offsets to space the canvas for cursor positioning
const VOFFSET = 32;
const HOFFSET = 35;

// Get the canvas element for handling
const canvas = document.getElementById('canvas_id');

// Get the insert button
const insertOnButton = document.getElementById('insert');

// Canvas context for drawing
const ctx = canvas.getContext('2d');

// Initial state for the insert button
let insertOn = true;

// Function to initialize the canvas size and appearance
//3/5/25 - add any missing funtionality, comment, and refactor 
function makeCanvas(verticalSize = 190, horizontalSize = 200) {
    // Set canvas display size
    canvas.style.width = `${horizontalSize}px`;
    canvas.style.height = `${verticalSize}px`;

    // For crisper imaging on high DPI screens
    const scale = window.devicePixelRatio;

    // Set the canvas' internal resolution to match the display size, scaled for better display
    canvas.width = horizontalSize * scale;
    canvas.height = verticalSize * scale;

    // Apply scaling to match the display resolution
    ctx.scale(scale, scale);

    // Set canvas background to white
    ctx.fillStyle = '#ffffff';

    // Clear canvas (white background)
    ctx.fillRect(0, 0, 200, 200);

    // Set font and text alignment
    ctx.font = '10px Monospace';
    ctx.textAlign = 'center';
}
 
  
  
  //draws grid
  //3/5/25 - add any missing funtionality, comment, and refactor 
  function drawGrid(iValue = HEIGHT, jValue = WIDTH) {
    // Ensure that gridArray is defined and has at least 'iValue' rows and 'jValue' columns
    if (!gridArray || gridArray.length < iValue || gridArray[0].length < jValue) {
        console.log("bad array");
        return; // Exit the function early if the grid is invalid
    }

    // Calculate the number of extra rows beyond the original height
    let extraHeightRows = HEIGHT - ORIGINALHEIGHT;
    // For each additional row, increase canvas height by 10 pixels
    let totalVert = extraHeightRows * 10 + STARTING_VERTI;

    // Make sure to resize the canvas with new dimensions
    makeCanvas(totalVert, STARTING_HORIZ);

    // Set the fill color for the header text (red)
    ctx.fillStyle = 'red';
    // Render the header text "Javascript Text Editor" at the top of the canvas
    ctx.fillText("Javascript Text Editor", 96, 18);

    // Set the fill color for the grid text (black)
    ctx.fillStyle = 'black';

    // Loop through the grid and render each cell's text
    for (let i = 0; i < iValue; i++) {
        for (let j = 0; j < jValue; j++) {
            // Check if the current grid cell exists and is valid
            let cellText = (gridArray[i] && gridArray[i][j]) ? gridArray[i][j] : ""; // Default to empty string if invalid
            // Calculate the x and y positions based on the grid layout
            let xPos = j * 5 + 30;
            let yPos = i * 10 + 33;
            // Render the text in the canvas at calculated positions
            ctx.fillText(cellText, xPos, yPos);
        }
    }
}

  //draws cursor on grid
  //3/5/25 - add any missing funtionality, comment, and refactor 
  function drawCursor(x,y){
    
    ctx.font = '10px Monospace'
    ctx.fillStyle = 'red'
    console.log("y: ", y)
    ctx.fillText('_', x - 5, y)
    }


    //holds key pressed
    let gKey = ''
    //array that holds key code, (number)
    var keyState = {}
    //let eventKeyCode = ""
    let down = false
    //gets the handles of these two buttons
    let inserting = document.getElementById('insert')
    let dashing = document.getElementById('areDashes')
    //sets up event handlers for both buttons
     inserting.addEventListener('pointerdown', handleInsertButtonClick)
     dashing.addEventListener('pointerdown', handleDashesButtonClick)
     //Left as a regular function in case of need for release event listener
     
     
  // Function to handle Insert button click event
  //3/5/25 - add any missing funtionality, comment, and refactor 
  function handleInsertButtonClick() {
  // Toggle the insertOn flag
  insertOn = !insertOn;

  // Get the insert button element
  const insertButton = document.getElementById("insert");

  // Check if the button exists to avoid runtime errors
  if (!insertButton) {
    console.error("Insert button element not found");
    return;
  }

  // Update button text based on the insertOn state
  insertButton.innerHTML = insertOn ? "Insert" : "On Top";
}
    

    // This function handles the button click to toggle between displaying dashes and spaces on the grid
     //3/5/25 - add any missing funtionality, comment, and refactor 
    function handleDashesButtonClick() {
    // Toggle the dash state: if showing dashes, switch to spaces, and vice versa.
    if (areDashes) {
        DASH = " ";  // Set DASH to space when toggling off
    } else {
        DASH = "-";  // Set DASH to dash when toggling on
    }

    // If currently displaying dashes, change grid content to spaces
    if (areDashes) {
        // Save a deep copy of the current grid state (with dashes) for future restoration
        copyArray = gridArray.map(arr => [...arr]);

        // Loop through the grid and replace all dashes with spaces
        for (let i = 0; i < HEIGHT; i++) {
            for (let j = 0; j < WIDTH; j++) {
                if (gridArray[i][j] === "-") {
                    gridArray[i][j] = " ";  // Replace dash with space
                }
            }
        }

        // Toggle the areDashes flag to indicate we are now showing spaces
        areDashes = !areDashes;

    } else {
        // If currently displaying spaces, restore the grid state with dashes
        gridArray = copyArray.map(arr => [...arr]);

        // Toggle the areDashes flag to indicate we are now showing dashes
        areDashes = !areDashes;
    }

    // Update the button text to reflect the current display state
    if (areDashes) {
        document.getElementById("areDashes").innerHTML = "Show Without Dashes";  // When showing dashes
    } else {
        document.getElementById("areDashes").innerHTML = "Continue Coding";  // When showing spaces
    }

    // Redraw the grid based on the current display mode (dashes or spaces)
    drawGrid(HEIGHT, WIDTH);

    // If dashes are being displayed, recursively update grid and cursor for display
    if (areDashes) {
        Recursive.displayGridAndCursor();
    }
}


    

   document.body.addEventListener('keydown', function (e) {
    // Mark the key as pressed based on its keyCode
    keyState[e.keyCode] = true;

    // Store the key that was pressed
    gKey = e.key;

    // Prevent multiple keydown events from triggering simultaneously
    if (down) return;
    down = true;

    // Call functions related to cursor movement and other actions
    cursorAndFunctionCalls();
    displayCursorLocations();

    // The event is simply captured and handled here
    }, false);

    document.addEventListener('keyup', function (e) {
    // Mark the key as released based on its keyCode
    keyState[e.keyCode] = false;

    // Store the key that was released
    gKey = e.key;

    // Reset the down flag as the key is no longer pressed
    down = false;

    // Simply captures the event
    }, false);
     
    //these keys dont do anything
    const preventKeys = [
    'Tab', 'PageUp', 'PageDown', 'Home', 'End','Control', 'Alt', 'Meta', 'Shift', 'Escape'
    ];
    
    // This function updates the display of the cursor's current horizontal and vertical positions
    //3/5/25 - add any missing funtionality, comment, and refactor 
    function displayCursorLocations() {
    // Get the DOM element where the cursor positions will be displayed
    let cursorDisplayElement = document.getElementById("xAndY");

    // Calculate the cursor's horizontal and vertical positions (scaled by 5 and 10, respectively)
    // These divisions are used to map the grid's cursor positions to human-readable coordinates
    let horizontalPosition = horizontalCursorPosition / 5;  // Horizontal position scaled by 5
    let verticalPosition = verticalCursorPosition / 10;    // Vertical position scaled by 10

    // Update the inner HTML of the element to display the current cursor positions
    cursorDisplayElement.innerHTML = 
        'Horizontal: ' + horizontalPosition + ' &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ' + 
        'Vertical: ' + verticalPosition;
}


    // This function handles the cursor movements and function calls based on key presses
    //3/5/25 - add any missing funtionality, comment, and refactor 
    function cursorAndFunctionCalls(event) {
    // Display the current cursor positions (this line is currently commented out)
    // displayCursorLocations();

    // Check if the key pressed is in the preventKeys array, and if so, return without doing anything
    for (let i = 0; i < preventKeys.length; i++) {
        if (preventKeys[i] == gKey) {
            return;  // Exit the function if the key is in the preventKeys list
        }
    }

    // Handle cursor movement based on arrow keys
    if (keyState[39]) {  // Right arrow
        CursorMovements.cursorRight();
    }
    else if (keyState[37]) {  // Left arrow
        CursorMovements.cursorLeft();
    }
    else if (keyState[38]) {  // Up arrow
        CursorMovements.cursorUp();
    }
    else if (keyState[40]) {  // Down arrow
        CursorMovements.cursorDown();
    }

    // Handle functions for non-cursor movement keys
    else if (gKey === 'Delete' || gKey === 'Backspace') {
        // If Delete or Backspace is pressed, delete the character at the cursor position
        gridArray = Recursive.deleteAndPullCharacters(verticalCursorPosition / 10, horizontalCursorPosition / 5, gridArray);
    }
    else if (gKey == "Enter") {
        // If Enter is pressed, perform the action associated with Enter (e.g., adding a newline)
        gridArray = Recursive.pressedEnter(gridArray, verticalCursorPosition / 10, horizontalCursorPosition / 5, "", true, HEIGHT - 1);
    }
    else if (gKey !== "") {
        // If a character key is pressed, determine whether to insert or overwrite the character
        if (insertOn === true && gKey) {
            // Regular insert mode (moves text to insert the character)
            gridArray = Recursive.initialInsertDoThisFirst(verticalCursorPosition / 10, horizontalCursorPosition / 5, gridArray, gKey, true);
        } else {
            // Destructive insert mode (overwrites the character at the cursor)
            gridArray = Recursive.placeCharacterWithoutInsertDoThisFirst(verticalCursorPosition / 10, horizontalCursorPosition / 5, gridArray, gKey);
        }
    }

    // Ensure that words within the grid don't overflow and adjust if needed
    gridArray = Recursive.pushWordsDoThisSecond(gridArray, ["Z"], 1, true);

    // Redraw the grid and update the cursor display after any changes
    Recursive.displayGridAndCursor();
}
    cursorAndFunctionCalls(event)
     </script>
    </body>
